# 学习笔记

## 哈希表（散列表 Hash Table）

- 散列表用的是数组支持按照下标随机访问数据的特性，所以**散列表其实就是数组的一种扩展**，由数组演化而来。可以说，如果没有数组，就没有散列表。
- 是根据关键码值（key value）而直接进行访问的数据结构。
- 通过把关键码值映射到表中的一个位置来访问记录。以加快查找速度。
- 映射的函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表
- 散列表用的就是**数组支持按照下标随机访问的时候**，时间复杂度是 O(1) 的特性。

### 散列冲突

- 不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的
- 当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用**装载因子**（load factor）来表示空位的多少。
- 散列表的装载因子=填入表中的元素个数/散列表的长度
- **装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。**

1. **开放寻址法**：核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入
2. **链表法**：一种更加常用的散列冲突解决办法。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。

**何为一个工业级的散列表？工业级的散列表应该具有哪些特性？**

- 支持快速地查询、插入、删除操作；
- 内存占用合理，不能浪费过多的内存空间；
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

**如何实现这样一个散列表呢？**

- 设计一个合适的散列函数；
- 定义装载因子阈值，并且设计动态扩容策略；
- 选择合适的散列冲突解决方法。

## 映射（Map）和集合（Set）

- 映射以（key，value）的形式存储元素，key不重复
- 集合是不重复的元素的集合（并集、交集、差集和子集）

## 树

- 一种非线性表结构
- 节点
  - 根节点：树只有一个根结点
  - 结点的度：结点拥有的子树的数量
    - **度为0：叶子结点或者终端结点**
    - **度不为0：分支结点或者非终端结点**
  - 分支结点除去根结点也称为内部结点
- 树的度：树中所有结点的度数的最大值
- **节点的高度 = 节点到叶子节点的最长路径（边数）**
- **节点的深度 = 根节点到这个节点所经历的边的个数**
- **节点的层数 = 节点的深度 + 1**
- **树的高度 = 根节点的高度**
- **树的深度取决于所有节点的深度的最大值**

```text
                  高度    深度    层
        O   ->     3       0      1
       / \
      O   O   ->   2       1      2
     / \ / \
    O  O O  O  ->  1       2      3
   / \     /
  O   O   O    ->  0       3      4
```

### 二叉树

- 每个节点最多有两个“叉”，也就是两个子节点，分别是**左子节点**和**右子节点**
- 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做**满二叉树**
- 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做**完全二叉树**

**如何表示（或者存储）一棵二叉树？**

有两种方法，一种是**基于指针或者引用的二叉链式存储法**，一种是**基于数组的顺序存储法**。

- 顺序存储结构：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。根节点存储在下标 `i = 0` 的位置，那左子节点存储在下标 `2 * i +1` 的位置，右子节点存储在 `2 * i + 2` 的位置。**适合完全二叉树**
- 链式存储结构：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。

#### 二叉树的遍历

- 经典的方法有三种，**前序遍历、中序遍历和后序遍历**
- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树（根》左》右）。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树（左》根》右）。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身（左》右》根）。

- **二叉树的前、中、后序遍历就是一个递归的过程**
- 每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说**二叉树遍历的时间复杂度是 O(n)**。

```text
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

**关于层序遍历一个解决思路：**层次遍历需要借助队列这样一个辅助数据结构。（其实也可以不用，这样就要自己手动去处理节点的关系，代码不太好理解，好处就是空间复杂度是o(1)。不过用队列比较好理解，缺点就是空间复杂度是o(n)）。根节点先入队列，然后队列不空，取出对头元素，如果左孩子存在就入列队，否则什么也不做，右孩子同理。直到队列为空，则表示树层次遍历结束。树的层次遍历，其实也是一个**广度优先**的遍历算法。

### 二叉查找树或二叉搜索树（Binary Search Tree）

- **二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值**。
- 左子树上所有结点的值均小于它根结点
- 右子树上所有结点的值均大于它根结点
- **升序排序**就是中序遍历，**时间复杂度是 O(n)，非常高效**

1. **查找操作**：先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。
2. **插入操作**：如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。
3. **删除操作**：三种情况
   - 如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 null。
   - 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了
   - 如果要删除的节点有两个子节点，找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，**因为最小节点肯定没有左子节点**（如果有左子结点，那就不是最小节点了）**二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”**，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，**比较浪费内存空间**，但是删除操作就变得简单了很多
4. **支持重复数据的二叉查找树**
   - 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上（**哈希冲突的解决方法**）
   - 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将**这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理**。当要查找数据的时候，遇到值相同的节点，**并不停止查找操作，而是继续在右子树中查找**，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

5. **时间复杂度**
   - 根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。
   - 二叉查找树是一棵完全二叉树（或满二叉树），**时间复杂度其实都跟树的高度成正比，也就是 O(height)**。
   - 平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。

留坑：**求出一棵给定二叉树的确切高度呢？**

确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。**递归法，根节点高度=max(左子树高度，右子树高度)+1**

## 堆

- 堆是一种特殊的树。
- 堆是一个**完全二叉树**（适合数组存储）
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
- 对于每个节点的值都大于等于子树中每个节点值的堆，叫做“**大顶堆**”。对于每个节点的值都小于等于子树中每个节点值的堆，叫做“**小顶堆**”。
- 左孩子（`2*i+1`）右孩子（`2*i+2`）父节点`Math.floor((i+1)/2)`

1. **往堆中插入一个元素**：把元素放到数组最后，调整，让其满足堆的特性(**堆化heapify**)(**从下往上的堆化方法**)让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。
2. **删除堆顶元素**：把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是**从上往下的堆化方法**。
3. 往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

### 堆排序

堆排序的过程大致分解成两个大的步骤，**建堆**和**排序**。

建堆操作的时间复杂度是多少呢？每个节点堆化的时间复杂度是 O(logn)，那 2n​+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 O(n)

排序：依次取出堆顶元素。

**堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)**。

**为什么快速排序要比堆排序性能好？**

第一点，**堆排序数据访问的方式没有快速排序友好。**对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，**这样对 CPU 缓存是不友好的**。第二点，对于同样的数据，在排序过程中，**堆排序算法的数据交换次数要多于快速排序**。我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，**建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。**比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

### 堆的应用

1. **优先队列**
   - 在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。
   - **一个堆就可以看作一个优先级队列**。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。
2. **利用堆求 Top K**
   - 针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。
   - 针对动态数据求得 Top K 就是实时 Top K。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。
3. 利用堆求中位数
   - 中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 n/2 个数据就是中位数（注意：假设数据是从 0 开始编号的）；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 n/2​ 个和第 n/2​+1 个数据
   - 对于一组静态数据，中位数是固定的，我们可以先排序，第 n/2 个数据就是中位数
   - 借助堆这种数据结构，就可以非常高效地实现求中位数操作
   - **需要维护两个堆，一个大顶堆，一个小顶堆**。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。**如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。**两个堆中的数据个数不符合前面约定的情况，可以从一个堆中不停地将堆顶元素移动到另一个堆。
