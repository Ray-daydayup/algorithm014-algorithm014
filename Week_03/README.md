# 学习笔记

## 递归

递归需要满足的三个条件：

- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件

**注意点**：

- 警惕堆栈溢出
- 警惕重复计算
- **写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**
- **编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**
- **数学归纳法思维**

### 递归树

- **借助递归树来分析递归算法的时间复杂度**
- 递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。
- 如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作**递归树**。
- **我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)**。

## 分治算法

- 分治算法（divide and conquer）的核心思想其实就是四个字，**分而治之** ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，**递归地解决这些子问题，然后再合并其结果**，就得到原问题的解。
- 分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：
  - 分解：将原问题分解成一系列子问题；
  - 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
  - 合并：将子问题的结果合并成原问题。
- 分治算法能解决的问题，一般需要满足下面这几个条件：
  - 原问题与分解成的小问题具有相同的模式；
  - 原问题分解成的子问题可以独立求解，子问题之间没有相关性；
  - 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
  - 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

## 回溯算法

- 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。
- 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
  - 找到一个可能存在的正确的答案；
  - 在尝试了所有可能的分步方法后宣告该问题没有答案。
- 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
- **回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。**它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。
