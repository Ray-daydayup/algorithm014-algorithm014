# 学习笔记

## 贪心算法

1. 第一步，当看到这类问题的时候，首先要联想到贪心算法：**针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大**。
2. 第二步，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。
3. 第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。

实际上，**用贪心算法解决问题的思路，并不总能给出最优解**。

- 分糖果
- 钱币找零
- 区间覆盖
  - 假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？
- 不要刻意去记忆贪心算法的原理，**多练习才是最有效的学习方法**。

## 二分查找

二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

O(logn) **对数时间复杂度**

### 代码模板

```js
function bSearch (numbers, target) {
  let left = 0
  let right = numbers.length-1
  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2)
    if (numbers[mid] === target) {
      // do something
      return or break
    } else if (numbers[mid] < target) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  // do something
  return false
}
```

三个易错点：

1. 循环退出条件：`left <= right`
2. mid 的取值：`Math.floor(left + (right - left) / 2)`，防止溢出
3. 左右边界的更新：`left = mid + 1`和`right = mid - 1`

## 二分查找应用场景的局限性

1. **二分查找依赖的是顺序表结构**
2. **二分查找针对的是有序数据**
3. **数据量太小不适合二分查找** 如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。
4. **数据量太大也不适合二分查找**
