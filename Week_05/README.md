# 学习笔记

1. 重复性（分治）
2. 定义状态
3. DP方程

超哥说：要注意找到一个所谓的自相似的办法，也就是有重复性的方法，把它化繁为简，同时逻辑上是简洁的且能够严谨来证明的。

## 一个模型三个特征

“一个模型”指的是动态规划适合解决的问题的模型--“**多阶段决策最优解模型**”。
我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

什么是“三个特征”？**它们分别是最优子结构、无后效性和重复子问题**。

1. **最优子结构**指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，**后面阶段的状态可以通过前面阶段的状态推导出来**。
2. **无后效性**有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，**某阶段状态一旦确定，就不受之后阶段的决策影响**。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
3. **重复子问题**如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

## 两种动态规划解题思路总结

1. **状态转移表法**
   - 一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。
   - **避免重复子问题**使用动态规划的解决方法，**状态转移表法**。
   - **我们先画出一个状态表**。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，**分阶段填充状态表中的每个状态**。最后，**我们将这个递推填表的过程，翻译成代码**，就是动态规划代码了。
   - 但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是**高维**的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了
2. **状态转移方程法**
   - 状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。**根据最优子结构，写出递归公式，也就是所谓的状态转移方程**。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，**一种是递归加“备忘录”，另一种是迭代递推**。
   - **状态转移方程**是解决动态规划的关键

**回溯算法**是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过,**回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了**。

并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，**需要满足三个特征，最优子结构、无后效性和重复子问题**。在重复子问题这一点上，**动态规划和分治算法的区分非常明显**。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，**通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解**。

## 总结

- 状态转移表法解题思路大致可以概括为，**回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码**。
- **状态转移方程法的大致思路可以概括为，找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码**
